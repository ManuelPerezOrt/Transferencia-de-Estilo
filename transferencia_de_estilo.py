# -*- coding: utf-8 -*-
"""Transferencia de Estilo

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TmhUTnSCVfBP501akR8TO7EVEoYinemA

# **Tarea Redes Neuronales: Transferencia de Estilo**
Por: Juan Manuel Pérez Ortega
"""

#Importamos librerias necesarias

import numpy as np
import tensorflow as tf
from tensorflow.keras import Model
from tensorflow.keras.applications.vgg19 import VGG19, preprocess_input
from tqdm import tqdm
import cv2

#Establecemos la dimensión de imagen, leemos el archivo de imagen, lo
#decodificamos en un tensor de 3 canales, convertimos el tipon de datos en
#float, redimenciona la imagen

def load_image(image_path):
    dimension = 512
    image = tf.io.read_file(image_path)
    image = tf.image.decode_jpeg(image, channels=3)
    image = tf.image.convert_image_dtype(image, tf.float32)
    shape = tf.cast(tf.shape(image)[:-1], tf.float32)
    longest_dimension = tf.reduce_max(shape)
    scale = dimension / longest_dimension
    new_shape = tf.cast(shape * scale, tf.int32)
    image = tf.image.resize(image, new_shape)
    return image[tf.newaxis, :]

# Si la imagen es un tensor de TensorFlow, primero elimina la
#dimensión extra añadida anteriormente y luego la convierte a
#una matriz de NumPy.

def tensor_to_numpy(image):
    if type(image) == np.ndarray:
        return image
    return tf.keras.backend.eval(tf.squeeze(image, axis=0))

def show_image(image, title):
    image = cv2.cvtColor(image, cv2.COLOR_RGB2BGR)
    cv2.imshow(title, image)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

# Clase para transferir estilos entre imágenes
class StyleTransferrer:
    # Inicialización de la clase
    def __init__(self, content_layers=None, style_layers=None):
        # Carga el modelo VGG19 con pesos pre-entrenados
        model = VGG19(weights='imagenet', include_top=False)
        # Desactiva el entrenamiento del modelo
        model.trainable = False
        # Define los pesos para el estilo y el contenido
        self.style_weight = 1e-2
        self.content_weight = 1e4
        # Define las capas de contenido y estilo
        self.content_layers = content_layers if content_layers else ['block5_conv2']
        self.style_layers = style_layers if style_layers else ['block1_conv1', 'block2_conv1',
                                                               'block3_conv1', 'block4_conv1',
                                                               'block5_conv1']
        # Obtiene las salidas de las capas de contenido y estilo
        outputs = [model.get_layer(name).output for name in (self.style_layers + self.content_layers)]
        # Crea un modelo de estilo con las salidas de las capas de contenido y estilo
        self.style_model = Model([model.input], outputs)
        # Define el optimizador
        self.optimizer = tf.optimizers.Adam(learning_rate=2e-2, beta_1=0.99, epsilon=0.1)

    # Función para calcular la matriz de Gram de un tensor
    def _gram_matrix(self, input_tensor):
        result = tf.linalg.einsum('bijc,bijd->bcd', input_tensor, input_tensor)
        num_locations = tf.cast(tf.shape(input_tensor)[1] * tf.shape(input_tensor)[2], tf.float32)
        return result / num_locations

    # Función para calcular las salidas de las capas de contenido y estilo
    def _calc_outputs(self, inputs):
        inputs = inputs * 255
        preprocessed_input = preprocess_input(inputs)
        outputs = self.style_model(preprocessed_input)
        style_outputs = [self._gram_matrix(style_output) for style_output in outputs[:len(self.style_layers)]]
        content_outputs = outputs[len(self.style_layers):]
        return {'content': {content_name: value for content_name, value in zip(self.content_layers,
                                                                               content_outputs)},
                'style': {style_name: value for style_name, value in zip(self.style_layers, style_outputs)}}

    # Función para recortar los valores de una imagen entre 0 y 1
    @staticmethod
    def _clip_0_1(image):
        return tf.clip_by_value(image, clip_value_min=0.0, clip_value_max=1.0)

    # Función para calcular la pérdida entre las salidas y los objetivos
    @staticmethod
    def _compute_loss(outputs, targets):
        return tf.add_n([tf.reduce_mean((outputs[key] - targets[key]) ** 2) for key in outputs.keys()])

    # Función para calcular la pérdida total
    def _calc_total_loss(self, outputs, style_targets, content_targets):
        style_outputs = outputs['style']
        content_outputs = outputs['content']
        s_loss = self._compute_loss(style_outputs, style_targets) * self.style_weight / len(self.style_layers)
        c_loss = self._compute_loss(content_outputs, content_targets) * self.content_weight / len(self.content_layers)
        return s_loss + c_loss

    # Función para entrenar el modelo
    @tf.function
    def _train(self, image, s_targets, c_targets, epochs, steps_per_epoch):
       for _ in tqdm(range(epochs)):
        for _ in range(steps_per_epoch):
            with tf.GradientTape() as tape:
                outputs = self._calc_outputs(image)
                loss = self._calc_total_loss(outputs, s_targets, c_targets)
            grad = tape.gradient(loss, image)
            self.optimizer.apply_gradients([(grad, image)])
            image.assign(self._clip_0_1(image))
       return image

    # Función para convertir un tensor a una imagen
    @staticmethod
    def _tensor_to_image(tensor):
        tensor = tensor * 255
        return np.array(tensor, dtype=np.uint8)[0]

    # Función para realizar la transferencia de estilo
    def transfer(self, s_image, c_image, epochs=10, steps_per_epoch=100):
        s_targets = self._calc_outputs(s_image)['style']
        c_targets = self._calc_outputs(c_image)['content']
        image = tf.Variable(c_image)
        image = self._train(image, s_targets, c_targets, epochs, steps_per_epoch)
        return self._tensor_to_image(image)

"""# **Modelo Completo y Prueba**

"""

# Crea una instancia de la clase StyleTransferrer
transferrer = StyleTransferrer()
# Visualiza el modelo
transferrer.style_model.summary()

# Importa la función para subir archivos en Google Colab
from google.colab import files
# Sube los archivos
uploaded = files.upload()

# Obtiene las rutas de las imágenes de contenido y estilo
content_path = list(uploaded.keys())[0]
style_path = list(uploaded.keys())[1]

# Carga las imágenes de contenido y estilo
content_image = load_image(content_path)
style_image = load_image(style_path)

# Importa la biblioteca para visualizar las imágenes
import matplotlib.pyplot as plt

# Define una función para mostrar las imágenes
def imshow(image, title=None):
    if len(image.shape) > 3:
        image = tf.squeeze(image, axis=0)
    plt.imshow(image)
    if title:
        plt.title(title)

# Muestra las imágenes de contenido y estilo
imshow(tensor_to_numpy(content_image), 'Contenido')
plt.show()
imshow(tensor_to_numpy(style_image), 'Estilo')
plt.show()

# Crea una instancia de la clase StyleTransferrer
transferrer = StyleTransferrer()

# Inicializa la imagen estilizada con la imagen de contenido
stylized_image = tf.Variable(content_image)

# Calcula las salidas de las capas de contenido y estilo para las imágenes de contenido y estilo
s_targets = transferrer._calc_outputs(style_image)['style']
c_targets = transferrer._calc_outputs(content_image)['content']

# Entrena el modelo para transferir el estilo de la imagen de estilo a la imagen de contenido
stylized_image = transferrer._train(stylized_image, s_targets, c_targets, epochs=20, steps_per_epoch=50)

# Convierte la imagen estilizada a una matriz de NumPy
stylized_image = tensor_to_numpy(stylized_image)

# Muestra la imagen estilizada
imshow(stylized_image, 'Resultado')
plt.show()

"""# **Resultado Final**"""

# Importa la función para subir archivos en Google Colab
from google.colab import files
# Sube los archivos
uploaded = files.upload()

# Obtiene las rutas de las imágenes de contenido y estilo
content_path = list(uploaded.keys())[0]
style_path = list(uploaded.keys())[1]

# Carga las imágenes de contenido y estilo
content_image = load_image(content_path)
style_image = load_image(style_path)

# Importa la biblioteca para visualizar las imágenes
import matplotlib.pyplot as plt

# Define una función para mostrar las imágenes
def imshow(image, title=None):
    if len(image.shape) > 3:
        image = tf.squeeze(image, axis=0)
    plt.imshow(image)
    if title:
        plt.title(title)

# Muestra las imágenes de contenido y estilo
imshow(tensor_to_numpy(content_image), 'Contenido')
plt.show()
imshow(tensor_to_numpy(style_image), 'Estilo')
plt.show()

# Crea una instancia de la clase StyleTransferrer
transferrer = StyleTransferrer()

# Inicializa la imagen estilizada con la imagen de contenido
stylized_image = tf.Variable(content_image)

# Calcula las salidas de las capas de contenido y estilo para las imágenes de contenido y estilo
s_targets = transferrer._calc_outputs(style_image)['style']
c_targets = transferrer._calc_outputs(content_image)['content']

# Entrena el modelo para transferir el estilo de la imagen de estilo a la imagen de contenido
stylized_image = transferrer._train(stylized_image, s_targets, c_targets, epochs=50, steps_per_epoch=50)

# Convierte la imagen estilizada a una matriz de NumPy
stylized_image = tensor_to_numpy(stylized_image)

# Muestra la imagen estilizada
imshow(stylized_image, 'Resultado')
plt.show()